\section{Grammaire implémentée}
D'abord, nous avons conçu notre programme comme un nombre indéterminé d'instructions.
Cette dernière se définissant par soit une assignation, un affichage, un ajout, une condition, une boucle ou encore une expression.
Le ";" n'a pas été défini globalement mais au cas par cas car les conditions et les boucles sont délimitées par des accolades.
Nous allons passer en revue chacun de ces instructions:

\subsection{Les déclarations}
Une déclaration est simplement définie par un type, une variable ainsi que potentiellement initialisée avec une expression.
Le langage SPF contient quatres types:

\begin{itemize}
\item booléen
\item entier
\item texte
\item liste
\end{itemize}

Notez qu'une liste est définie comme une liste de valeur peu importe le type ou alors par une séquence de nombre entier.
Une variable quant à elle doit respecter la grammaire suivante:
Le nom d’une variable est composé au minimum d’un caractère, ne peut contenir que des lettres (majuscules et minuscules) accentuées ou non, des chiffres ou un tiret bas. Le nom d’une variable ne peut pas débuter par un chiffre.
Nous avons donc obligé un premier terme avec une lettre ou un underscore et ensuite un nombre indéterminé de lettre, de chiffres et d'underscore.
Nous reparlerons de la grammaire d'une expression

\subsection{Les assignations}
Elles sont très similaires aux déclarations mises à par le fait que le type ne doit plus être précisé mais maintenant, il faut obligatoirement une expression.

\subsection{L'affichage}
\textbf{afficher} prend simplement une suite d'au moins une expression séparée par des virgules.
Nous nous sommes également permis de rajouter la possibilité d'afficher directement le résultat de l'instruction \textbf{ajout}.

\subsection{L'ajout}
Pour \textbf{ajout}, nous définissons une grammaire avec une expression et une variable dans laquelle sera rajoutée le résultat de l'expression.

\subsection{Les boucles}
\textbf{boucle} représente simplement les deux possibilités de boucle offertes par le langage SPF.
À savoir \textbf{tantque} qui prend une expression et une suite d'instructions. Et \textbf{pourchaque} qui a également besoin d'une variable et de son type.

\subsection{Les conditions}
Tout comme le point précédent, \textbf{condition} contient une règle \textbf{si} qui exécute les instructions en fonction de la condition.
Et \textbf{sisinon}, une extension de \textbf{si} qui prend en plus d'autres instructions dans un autre corps d'accolades.

\subsection{Les expressions}
Les expressions se définissent de base comme des litéraux ou des opérations mais peuvent être englobées par des parenthèses pour émettre des priorités ou encore être représentées par une variable.

\subsubsection{Les litéraux}
Les litéraux représentent toutes les valeurs possibles par rapport aux quatre types de ce langage.

\paragraph{Les booléens}: Valant soit \textit{vrai} soit \textit{faux}.

\paragraph{Les entiers}: Une séquence de chiffre ne commençant pas par 0 sauf si c'est pour représenter 0. Il peut optionnellement avoir un \textit{plus}.

\paragraph{Les textes}: Une suite de n'importe quels symboles entre deux \textit{guillemets}.

\paragraph{Les listes}: Soit une liste d'expression entre \textit{crochets} séparé par des \textit{virgules}.
Soit une sequence définie par deux expressions entre \textit{crochets} séparées par un \textit{deux-points}.

\subsubsection{Les opérations}
Mises à part les opérations \textbf{indice} et\textbf{taille}, les autres opérations sont toutes composées d'une ou deux expressionx
ainsi que de mot clés pour les différencier. Attention au niveau des opérations mathématiques, nous avons mis en place les règles \textbf{exp1} et \textbf{exp2}
pour émettre des priorités dans les calculs.
Rien de spécial côté \textbf{indice}, il prend deux expressions dont la deuxième entre \textit{crochets}.
Pour finir, \textbf{taille} peut recevoir soit \textbf{leslistes} (une \textbf{liste} ou une \textbf{sequence})
mais aussi une variable qui contiendra une des deux valeurs précédement citées.

\subsection{Autres}
Nous avons également défini une règle pour ignorer tous les espaces blancs et une règle pour ignorer tous les caractères après un \textit{dièse} sur une ligne.

\section{Notre approche}
\subsection{Les variables}
Nous avons d'abord créé une classe pour stocker les caractéristiques des variables à savoir, leur type, leur nom, leur valeur
mais également les types des valeurs contenues dans la liste si la variable en est une.
C'est la classe \textbf{Memory} qui a permis de facilement interagir avec les variables grâce aux méthodes \textit{declare}, \textit{get} et \textit{set}.
Utiliser les variables dans les expressions était facilent car il suffisait de remplacer les variables par leurs valeurs et leurs types
quand on se trouvait sur un noeud \textbf{exp}.
Les affichages liés au mode \textit{debug} ont très rapidement été mis en place étant donné qu'il suffisait d'ajouter
un affichage aux trois méthodes citées précédemment avec les informations adéquates.
Dans le cas du mode \textit{memory}, on parcourt simplement le dictionnaire contenant toutes les variables.

\subsection{Le test conditionnel}
La condition \textit{si} n'a pas pris longtemps à être ajouté car à ce stade, on avait déjà compris comment utiliser l'arbre et
donc compris comment accéder à la condition pour ensuite itérer sur le reste des instructions. 
Concernant \textit{sisinon}, il fallait juste récupérer le résultat du \textit{si} et ensuite exécuter ou non
les instructions se trouvant dans le corps de \textit{sisinon}.

\subsection{Les boucles}
La boucle \textit{tantque} fût très rapide également car la condition fonctionne tout comme les tests conditionnels.
Nous avons aussi compris qu'une fois l'arbre parcouru, il se transformait et qu'il fallait donc dans le cas des boucles,
sauvegarder les instructions se trouvant dans le corps avant de les parcourir.
La boucle \textit{pourchaque} n'était pas beaucoup plus complexe sur le papier mis à part si la variable créée existe déjà.
Une première approche à consister à utiliser un deuxième dictionnaire dans la mémoire qui contenait les variables ne pouvant pas être utilisées temporairement
mais cela causait un problème.
En effet, si on a créé une variable et qu'ensuite il y a deux boucles imbriquées \textit{pourchaque} avec le même nom que la variable initiale
alors on perdait notre valeur initial et on se retrouvait avec une erreur.
La deuxième approche a donc été d'utiliser une pile au lieu d'un dictionnaire car c'est toujours la dernière variable ajoutée qui doit être retirée en première.

\section{Les erreurs connues, les solutions envisagées et les difficultés rencontrées}
Il y a actuellement aucune erreur connue, tous les teste ont fonctionné. Cependant, nous avons eu des difficultés pour la gestion des types dans les listes.
En effet, nous n'étions pas parti sur la meilleure solution dès le départ ce qui nous a embrouillés dans le code.
La solution finale a été de stocker les types des valeurs (contenues dans les listes) dans un tuple avec le type \textbf{liste} dans la partie type des Tokens.
Ce problème fut compliqué parce qu'il fallait prendre en compte qu'une liste pouvait avoir plusieurs dimensions.

Une autre difficulté du projet a été de se débrouiller avec une documentation bancale à propos du module lark.
Par exemple, les attributs de l'erreur UnexpectedCharacters n'étaient pas présents dans la documentation. Il a donc fallu aller voir le code source.
